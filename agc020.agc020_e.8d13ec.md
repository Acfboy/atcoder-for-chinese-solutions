---
title: "AGC020_E_solution.md"
tags: []
author: ""
created: ""
---



[AGC020E](https://atcoder.jp/contests/agc020/tasks/agc020_e)

<!-- more -->

模拟时碰到的感觉很厉害的一道题。

吐槽一下，咋放了一个两千九的《签到题》（指一半人做出来）（悲）

然后我非常的菜，甚至没有做出 $n=10$ 的 $30$ 分部分分。

---

容易发现，如果从左往右进行操作，操作结果和操作序列是一一对应的，不存在两种不同的操作方法得到相同的结果。

假如 $n=10$，可以考虑枚举 $S$ 的子集并对每一种情况 dp，令 $f(l,r)$ 表示考虑当前子集的 $[l,r]$ 区间有多少种不同的方案。

我其实想到了这一步。但是转移的时候还是略显幼稚，因为总是无法不重不漏地转移：大概思路就是从中间挖掉若干个区间云云。

显然，我当时没想清楚的是，如果挖掉一个区间，必须钦定其被压缩，所以还要再令 $g(l,r)$ 表示考虑当前子集的 $[l,r]$ 区间有多少种被钦定压缩的方案。转移如下：

$$
\displaylines {f(l,r)=\sum_{i\in[l,r)} g[l,i]\times f(i,r]\\
g(l,r)=\sum_{i|len(l,r)}f(l,l+i-1)\bigg[s[l,l+i-1]=s[l+i,l+2\times i-1]=\dots=s[r-i+1,r]\bigg]}
$$

这一步想清楚了，感觉离正解的距离就近了一大步。

如果令 $f(l,r)$ 表示考虑当前区间 $[l,r]$ 的所有子集方案数的总和，$g(l,r)$ 同理，能否按照相同的方法转移？

答案是可以的。

$f$ 的转移没有任何区别，尝试解决 $g$ 的转移问题。

考虑枚举长度，肯定是要转移到 $f$ 的，因此就直接转移到 $f(s[l,l+i-1] \And s[l+i,l+2\times i-1] \And \dots \And s[r-i+1,r])$，其中 $\And$ 表示按位与。这一步也非常巧妙，愚蠢的我再一次没有想到这一点。但是可以发现，此时的字符串不一定是 $s$ 的子段，因此不能存区间，而应该直接存字符串，可以用 $map$ 记录这个东西，状态个数是不超过 $\mathcal O(n^3)$ 的。

时间复杂度：不太确定，姑且认为是 $\mathcal O(n^4)$ 的，但是应该无法达到，因为虽然 $f$ 的转移是 $\mathcal O(n)$ 的，但 $g$ 的转移是 $\mathcal O(\log n)$ 的。

---

总结：好像最近遇到了好几次比较绕的区间 dp，而且一开始都没有想出来。说明对这个东西不够敏感。

我一开始把子集的定义理解错了（以为是子序列），后来虽然纠正过来了，貌似也对思考造成了一些影响。

(by ShmilyTY)

